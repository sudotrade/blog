---
title: "35% Obfuscation with Windows PE - Part 1"
date: 2020-09-28 17:14:00
---


I base this write on my personnal knowleg so I could make mistakes, errors about my explannations, so if you mention something wrong, thank to report me that

I have no pretentions, I'm just someone who have a passion and who try to share it,

Only native code here, no .net s***


Tricks manualy applied to executable, thoses methods can be use with tools to modify a finished executable to automate them, but for this presentation it's betther to make obfuscation manualy

Apply in a certain order to be powerfull

Some times it's very VERY easy to bypass some checks by just locking for parterns

Idk for strings, in a couple of seconds you can identify where a potential check is done

For me the best security is something that, when you take a first look, you can't handle anything like hidding the fact that is obfuscated. And when you finally found some check verification, it's something to long to decrypt, difficult but especially long crack

Part 1 : Why ? principles that make your code more harder to reverse

Part 2 : Obfuscation of the code form source code

Part 3 : Obfuscation of the executable from the stub

Part 4 : Wrapper / Protectors 


## Summary

Make the code harder to reverse / enderstand by humains :


Obfuscation and Malware :

Antivirus can make falsepositives


But can be used to hide malware, so It's important to now how security works in general, how defeat and create




## Simple principles

### If is commercial

DON'T LEAVE STRINGS BITCH
DON'T EXPLICITE NAME
DON'T EXPLICITE STRINGS LIKE "Thanks for purchase"
MAKE A SILENCE ACTIVATION
DON'T LEAVE THE FUCKING PDB FILE
DON'T MAKE TRIAL IDIOT
LEAVE THE TOOL ONLY AFTER BUYING
 
STOP TO LOG EVERYTHING ABOUT THE LICENCE CHECK PROCESS

### If you have a key check or license check

DON'T MAKE A SINGLE FUNCTION THAT CHECK THE KEY
DON'T MAKE A FUNCTION THAT RETURN 0 OR 1 IF IS GOOD OR NOT
MAKE DIFERRENT FUNCTIONS WITH A LOT OF CALLS

### More efficiant license system

DON'T MAKE A VALID KEY CHECK IN THE SOFTWARE

DON'T MAKE OFFLINE ACTIVATION, MAKE IT ONLINE

Store all keys on a server (like key that you crafted), if one is activated, store information about the user like HWID etc.. and compare it each time is loaded, if someone try to use the same key, compare again the HWID.  

USE CALLBACKS NOT DIRECT DATA TRANSMITION

### If you have to store / transmit important data

encrypt everything, files, datas, communications etc..

and DON'T USE A STATIC DECRYPTION KEY
USE THINGS LIKE A ID RELATED TO THE SYSTEM

DON'T USE WINDOWS DPAPI IS FUCKING USELESS

CHECK EVERY THING, FILE HASH

SECURITY CHECKS SHOULD BE GOOD, BUT IMPLEMENTATION IS MORE IMPROTANT


## From code

I will present some'e methods tricks of obfuscation that can be used any in

This main thing about obfuscation is to "hide" constants informations

### String obfuscation

### Using math's

### Using crypto

### Control flow

The main idea of the control flow is to break the main execution "Flow" of a normal program. Example, if we ask a product key to the user, after that in the code, we supposed to have the check about this key. The control flow will reogenize this code randomly to make ;;;;;;

the size ll

### Renaming

This work only if names are stored, like in a script or in some's high level languages


There is two approch, one where we don't care about the file size, and one with short names.

Example in C# :


Short names example of a root-me challenge :


Or one of the best example of renaming optimization : the google front page



This can help a lot when you use scripts with dynamic typing, example of Liveoverflow Google Ctf :


Note : you can use invalid characteres when it's possible or in post process to crash some modded execution tries.

Note 2 : this could be used to optimize script size


### MBA

### Unusual routines

### Anti debug

Something that can be really annoying if it's righttly applied, again I have'nt  


Personally I prefer

The


(loop when detected or crash)



## Around code

### Limit imports

sometime we use fonctions that we can just hardcode in awer program, this (with a little bit of obfuscation) can be nice if we want to hide methods

I think about memcpy memset strcpy etc....

LiveOverflow exemple pwnctf RSA

Or when you have to use libraries, import functions from addresses and use ordinal function number than names

Put security checks, decryption void in a efficiant place :


### CRC checking

NOTE : the only way to know the size of a function in self coding is to make a void and make a second void just after him, so the address deferce between thoses functions will be the size (again is you are sure that the order of function will not change or no variables of type will be added in the code, because all addresses will be remade after this)

In my exemple, I will consider that I know function size and I will hardcode it


### Encrypt sections

### Encrypt functions

### Resources encryption

### Junkcode

sdfgsgdsqgs

Is not very used because is not very efficiant

Make a good junkcode depends of your code it self

https://www.microsoft.com/security/blog/2018/03/01/finfisher-exposed-a-researchers-tale-of-defeating-traps-tricks-and-complex-virtual-machines/

### Limit imports :

sometime we use fonctions that we can just hardcode in awer program, this (with a little bit of obfuscation) can be nice if we want to hide methods

I think about memcpy memset strcpy etc....

LiveOverflow exemple pwnctf RSA

Or when you have to use libraries, import functions from addresses and use ordinal function number than names

Put security checks, decryption void in a efficiant place :


### CRC Checking :

NOTE : the only way to know the size of a function in self coding is to make a void and make a second void just after him, so the address deferce between thoses functions will be the size (again is you are sure that the order of function will not change or no variables of type will be added in the code, because all addresses will be remade after this)

In my exemple, I will consider that I know function size and I will hardcode it

### Packing 
### Wrappers 


### Exploit the Reversing Tool

recently x64dbg with the export address


    NumberOfRvaAndSizes > 0x10 in IMAGE_OPTIONAL_HEADER crashes OllyDBG 1.1.
    SizeOfRawData too big in IMAGE_SECTION_HEADER crashes OllyDBG 1.1.
    Calls to OutputDebugString with “%s” token crashes OllyDBG 1.1.


LOOK THIS guy exploit still exist




## Modern approach 
 
### Virtual Machine

### Polymorphic Code 

### Nanomites

### Metaprogramming 


## Conclusion

Are you still alive ????

## References

Microsoft Docs :

The Ultimate Anti-Debugging Reference : https://anti-reversing.com/Downloads/Anti-Reversing/The_Ultimate_Anti-Reversing_Reference.pdf
