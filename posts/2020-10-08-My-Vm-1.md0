---
title: "70% Creating an obfuscated VM - Part 1"
date: 2020-10-08 17:14:00
---

Introduction :

 

The objective is to create a simple VM, that will be obfuscated regarding its behavior.

The architecture I used is based, like any modern computer, on [Von Neumann](https://fr.wikipedia.org/wiki/Architecture_de_von_Neumann) machine arch.

Here is the source code of my project : https://github.com/whereisr0da/IDELA-VM-BASE

## I - CPU / Language bases


You need instructions, temporary storages (like RAM, Registers, Heap, Stack)  

In x86 it look like this :

![](/post_images/my_vm_1/x86.png)

It's a simple VM so we need something simple. 

A stack to store things temporarily, a heap to save data across the all the execution, and a simple conditional register. 

To handle the instructions, the stack and the function calls, pointers IP,  SP and CP will be used to control the execution flow.

![](/post_images/my_vm_1/idelaEnv.png)

About the implementation, it's looking like this :

![](/post_images/my_vm_1/Screenshot_137.png)

## II - Define a language 


To create a programming language, we need to create a list of task todo by the computer, in a form that it will understand them. How about creating basic instructions, like addition, substraction .. and create function that do the purpose of the instruction ? This is how CPUs and VMs works, as we will not reinvent the wheel, let's try this out.

So we need basic intructions :

Numberic operations : ADD, SUB, MUTL, DIV, OR, XOR, AND, ..

Move opertaions : JMP, CALL

Coditionals operations : CMP, JE, JNE, JBE, JLE, ..

Heap operations : SAVE, LOAD

Stack operations : POP, PUSH 

With all of this, we can already code interestings things. The only problem is about the VM interactions with its environment. Like taking user inputs in console, interact with the main vm assembly, open file, doig syscalls, call API .....

This language is a POC, so I will not implement all of this, but, to make this VM a little bit interactive, I will implement an instruction to get user inputs from console.

Interface operations : CINPUT ..

But, how to represent the instruction set ? Well simply by giving them an indicater, like a number, and if the number is found, the VM will know that it has to process this instruction.

Now how can we use the environment we setuped above with those instructions ? An example of processing with this calculation 2 + 2 :

![](/post_images/my_vm_1/stack.png)

We can use the stack to punctually store values to make operations. In this example, the instruction ADD8 will add to the last pushed value, the value pushed before it (values on 8 bits). And the instruction PRINTS8X will print the last stack value (of 8 bits again) in the console.

I will not make 1000 example programs, but you get the idea. The can help you to use data punctually, the heap store data permanently during the all execution.

About functions, the system ...

Now for the worker part of an instruction, I will create a function called "Handle" that will execute the instruction purpose.

For example here :

![](/post_images/my_vm_1/Screenshot_147.png)

The handle of the IADD8 will add a value in the instruction (vm->opcode[vm->ip]) to the top stack value (vm->stack[vm->sp])

Note : in my code, the instruction set is simple but "huge" for obfuscation purposes. A diversified instruction set is needed to make the opcode buffer less repetitive. It's why I'm doing one instruction per operation length (IPUSH8, IPUSH16, ...) unlike x86 or others.


## III - Mix all of this together 


We have an instruction set, we have an architecture, now we can build the dispatcher. A dispatcher a 


In this example, the IP (Instruction Pointer) point to the next instruction (IPUSH8 0x41) represented by the data "00 41". The dispatcher will read the first byte of the instruction (the identifier), and will select the according handle to execute the instruction.

![](/post_images/my_vm_1/Dispatcher.png)