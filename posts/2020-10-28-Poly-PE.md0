---
title: "45% Polymothism applied to Windows Executables"
date: 2020-10-28 17:14:00
---

Hi all.








Theories only, apply polymothism to

Very general because of my knowleg

## Why ?

(bypass hypervisor, IDS)

....


In shellcode's we care about the size, in executable it's not the case,

Fuzzing about Debuggers, Disassemblers, Antivirus, Hypervisors .... even Windows Kernel
.....

## Polymothism. Not Metamorphosis



## Commun struct modification

### Header and PE structures

#### DOS header

Considering that the PE executable will never use the DOS header (unless to jump to the PE header), we can write anything we want in it. We can even hide things in it (see [OsandaMalith's post](https://osandamalith.com/2020/07/19/exploring-the-ms-dos-stub/))

From ReactOS, here is the DOS Program struct :

```C
typedef struct _IMAGE_DOS_HEADER {
  WORD e_magic;
  WORD e_cblp;
  WORD e_cp;
  WORD e_crlc;
  WORD e_cparhdr;
  WORD e_minalloc;
  WORD e_maxalloc;
  WORD e_ss;
  WORD e_sp;
  WORD e_csum;
  WORD e_ip;
  WORD e_cs;
  WORD e_lfarlc;
  WORD e_ovno;
  WORD e_res[4];
  WORD e_oemid;
  WORD e_oeminfo;
  WORD e_res2[10];
  LONG e_lfanew;
} IMAGE_DOS_HEADER,*PIMAGE_DOS_HEADER;
```

So we can't avoid `e_magic` value `"MZ"` because it's the header of every DOS and PE programs, so nothing lost here because every file should get it.

`e_cblp` is 

`e_cp` is 

`e_crlc` is 

`e_cparhdr` is 

`e_minalloc` is 

`e_maxalloc` is 

// all are not used

`e_lfarlc` point to the relocation table of the DOS program (so in the gap between _IMAGE_DOS_HEADER end and _IMAGE_FILE_HEADER), so could be random too.

`e_res` and `e_res2` can be random as they are not used.

`e_lfanew` can't be randomized because it's an offset to the next header `_IMAGE_FILE_HEADER`, but right after the end of the struct, there is the DOS stub. So this could be randomized as long as your DOS stub is large.

About the stub program, you can write what ever you want in it as we are focused on PE code, and not DOS code.

#### File header

```C
typedef struct _IMAGE_FILE_HEADER {
	WORD Machine;
	WORD NumberOfSections;
	DWORD TimeDateStamp;
	DWORD PointerToSymbolTable;
	DWORD NumberOfSymbols;
	WORD SizeOfOptionalHeader;
	WORD Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
```

Again `Machine` value can't be avoid, its value should be `PE`, but like I said, it's always the same for every PE.

`NumberOfSections` could be random if you put new fake sections that point nowhere or with junk data, but it should always be above the real number of section of the program.

`TimeDateStamp` is the compilation date, so could be random x)

`PointerToSymbolTable`

`NumberOfSymbols`

Now we can try some intersting things, because the next header size is variable because of x86 and x64 header difference (and `NumberOfRvaAndSizes`). `SizeOfOptionalHeader` define its size, but we will see that later.

`Characteristics` can't be random because it define how the kernel will setup the executable environment (DYNAMIC LINKING RESOLVING....)

#### Optional header

This is the `_IMAGE_OPTIONAL_HEADER` for x86

```C
typedef struct _IMAGE_OPTIONAL_HEADER32 {
	WORD Magic;
	BYTE MajorLinkerVersion;
	BYTE MinorLinkerVersion;
	DWORD SizeOfCode;
	DWORD SizeOfInitializedData;
	DWORD SizeOfUninitializedData;
	DWORD AddressOfEntryPoint;
	DWORD BaseOfCode;
	DWORD BaseOfData;
	DWORD ImageBase;
	DWORD SectionAlignment;
	DWORD FileAlignment;
	WORD MajorOperatingSystemVersion;
	WORD MinorOperatingSystemVersion;
	WORD MajorImageVersion;
	WORD MinorImageVersion;
	WORD MajorSubsystemVersion;
	WORD MinorSubsystemVersion;
	DWORD Win32VersionValue;
	DWORD SizeOfImage;
	DWORD SizeOfHeaders;
	DWORD CheckSum;
	WORD Subsystem;
	WORD DllCharacteristics;
	DWORD SizeOfStackReserve;
	DWORD SizeOfStackCommit;
	DWORD SizeOfHeapReserve;
	DWORD SizeOfHeapCommit;
	DWORD LoaderFlags;
	DWORD NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32,*PIMAGE_OPTIONAL_HEADER32;
```

`Magic`

`MajorLinkerVersion` and `MinorLinkerVersion` give informations about the linker used during the compilation, so could be random.

`SizeOfCode`, `SizeOfInitializedData` and `SizeOfUninitializedData`

`AddressOfEntryPoint` could be random of course ! But it depend of the code and it's in the next part 

`BaseOfCode` and `BaseOfData`

`ImageBase` .... useless if ASLR ....

`SectionAlignment` and `FileAlignment`

`MajorOperatingSystemVersion`, `MinorOperatingSystemVersion`.. to `MinorSubsystemVersion` are up to you as it can prevent to use some Windows versions.

`Win32VersionValue`

`SizeOfImage`

`SizeOfHeaders`

I've never meet a PE using `CheckSum`, but some people told me that this is used for drivers, so I guess it could be random until it's not one.

`Subsystem` and `DllCharacteristics` can't be changed as they define the core process behavior (Window,Console,DEP,ASLR,...)

`SizeOfStackReserve` to `SizeOfHeapCommit` could be random, but aligned with system specs.

`LoaderFlags`


`NumberOfRvaAndSizes` is the number of `_IMAGE_DATA_DIRECTORY`

```C
typedef struct _IMAGE_DATA_DIRECTORY {
  DWORD VirtualAddress;
  DWORD Size;
} IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;
```


....

#### Section headers

Like I said, you could add fake sections : pointing to another section, pointing nowhere or with junk code in it.


```C
typedef struct _IMAGE_SECTION_HEADER {
  BYTE Name[IMAGE_SIZEOF_SHORT_NAME];
  union {
    DWORD PhysicalAddress;
    DWORD VirtualSize;
  } Misc;
  DWORD VirtualAddress;
  DWORD SizeOfRawData;
  DWORD PointerToRawData;
  DWORD PointerToRelocations;
  DWORD PointerToLinenumbers;
  WORD NumberOfRelocations;
  WORD NumberOfLinenumbers;
  DWORD Characteristics;
} IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER;
```

### Sections data

I will talk about general sections, but this could be applied to any type of section unless you understand what they content.

.text / .code section : 

this section contains the main asm code of the program, so this is the main part that we will work on.

.data section :

this section contains all data of the program like strings, numbers, ...
so the only way to polymorth is crypto with random key, .

at each compilation, xor strings with a random key


.?? (import table)

fake imports

Hide imports

random Exports (x64dbg bug)

ressource obfu

junk data in others `_IMAGE_DATA_DIRECTORY` (Debug, TLS, .Net ...)

### Other data

EOF

## Instruction modification

Concret modifications ...

### Code mutation

The main goal of this is to keep the algorithm, and change its form, we can change instructions be other that do same thing.

Exemple :

`mov eax, [edx]` : mov edx content in eax

Can be also represented as :

`xor eax, eax`   : xorring eax by it self to set it to 0

`xor eax, [edx]` : xorring 0 to the value of edx so set eax to edx value

There is a lot of things to do here and the only limit is your imagination, but don't forget to care about the file size and the performance.

Polymorthisme is used a lot in shellcoding, so you can get a lot of asm code obfuscation tricks from here.

Its complex to implement from the compiled executable (you need to dissasemble the assembly, interpret all address and modify them in function of your amount of code added, and reassemble the all thing).

You could try to modify the asm code after the compiler interpretation, and after compile the asm code, but I never succeded, mvc generate a code that cannot be compiled to him seft -_- (good luck tried to fix imports errors)

You can also use uncommun instructions

You can see a very good exemple here with VMProtect mutation engine : (TODO)

### Junkcode

junk is prety useless about polymorthism because your signature will be still there, you can radomize your junkcode but still

### Obfuscation

// SEE MY TUT

#### Control flow obfuscation

#### Encrypt functions

### Using simple tricks

SDK versions

Compilator versions

Optimisation options

### Virtualization

## Wrapping all of this

Packing, RunPE, ... with crypto

## Finalisation

(90% diff)

Scan time

Runtime